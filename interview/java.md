
#### 1.	接口的意义（百度）（Jason）
- 1、重要性：在Java语言中， abstract class 和interface 是支持抽象类定义的两种机制。正是由于这两种机制的存在，才赋予了Java强大的 面向对象能力。
 
- 2、简单、规范性：如果一个项目比较庞大，那么就需要一个能理清所有业务的架构师来定义一些主要的接口，这些接口不仅告诉开发人员你需要实现那些业务，而且也将命名规范限制住了（防止一些开发人员随便命名导致别的程序员无法看明白）。

- 3、维护、拓展性：比如你要做一个画板程序，其中里面有一个面板类，主要负责绘画功能，然后你就这样定义了这个类。可是在不久将来，你突然发现这个类满足不了你了，然后你又要重新设计这个类，更糟糕是你可能要放弃这个类，那么其他地方可能有引用他，这样修改起来很麻烦。<br>
 如果你一开始定义一个接口，把绘制功能放在接口里，然后定义类时实现这个接口，然后你只要用这个接口去引用实现它的类就行了，以后要换的话只不过是引用另一个类而已，这样就达到维护、拓展的方便性。

- 4、安全、严密性：接口是实现软件松耦合的重要手段，它描叙了系统对外的所有服务，而不涉及任何具体的实现细节。这样就比较安全、严密一些（一般软件服务商考虑的比较多）。

#### 2. 抽象类的意义（乐视）（Jason）
抽象类往往用来表征对问题领域进行分析、设计中得出的抽象概念，是对一系列看上去不同，但是本质上相同的具体概念的抽象。具体分析如下：
1.因为抽象类不能实例化对象，所以必须要有子类来实现它之后才能使用。这样就可以把一些具有相同属性和方法的组件进行抽象，这样更有利于代码和程序的维护。
2.当又有一个具有相似的组件产生时，只需要实现该抽象类就可以获得该抽象类的那些属性和方法。

#### 3.	内部类的作用(百度，乐视) （Jason）
定义：放在一个类的内部的类我们就叫内部类。
作用：
- 1.内部类可以很好的实现隐藏，一般的非内部类，是不允许有 private 与protected权限的，但内部类可以
- 2.内部类拥有外围类的所有元素的访问权限
- 3.可是实现多重继承
- 4.可以避免修改接口而实现同一个类中两种同名方法的调用。

#### 4. 父类的静态方法能否被子类重写，为什么？（猎豹）（Jason）
父类的静态方法是不能被子类重写的，其实重写只能适用于实例方法，不能用于静态方法，对于上面这种静态方法而言，我们应该称之为隐藏。
Java静态方法形式上可以重写，但从本质上来说不是Java的重写。因为静态方法只与类相关，不与具体实现相关。声明的是什么类，则引用相应类的静态方法(本来静态无需声明，可以直接引用)。并且static方法不是后期绑定的，它在编译期就绑定了。换句话说，这个方法不会进行多态的判断，只与声明的类有关。

#### 5. 举 1-2 个排序算法，并使用 java 代码实现（美团）（Danny）

#### 6. 列举 java 的集合和继承关系（百度、美团）（Jason）
![java集合和继承关系.png](https://upload-images.jianshu.io/upload_images/1128757-15b19f4d87e98015.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 7. java 虚拟机的特性（百度、乐视）（Jason）
- (1).运行时数据区域：程序计数器、java虚拟机栈、本地方法栈、java堆、方法区
- (2).主流对象访问方式：使用句柄和直接指针；
- (3).垃圾收集;
- (4).jdk1.2后分为强引用、软引用、弱引用、虚引用;
- (5).类加载器：启动类加载器、扩展类加载器、应用程序类加载器;
- (6).虚拟机字节码执行引擎（解释执行、编译执行;
- (7).解释器和编译器;
- (8).即时编译器编译优化技术;

#### 8. 哪些情况下的对象会被垃圾回收机制处理掉（乐视、美团、小米）（Jason）
- （1）超出对象的[引用句柄的作用域]时，这个引用句柄引用的对象就变成垃圾。
- （2）没有超出对象的引用句柄的作用域时，给这个[引用句柄赋值为空时]，这个引用句柄引用的对象就变成垃圾。
- （3）创建[匿名对象时]，匿名对象用完以后即成垃圾。

#### 9. 进程和线程的区别（猎豹）（Jason）
进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同。
- 1) 简而言之,一个[程序]至少有一个进程,一个进程至少有一个线程.
- 2) 线程的[划分尺度]小于进程，使得多线程程序的并发性高。
- 3) 另外，进程在执行过程中拥有独立的[内存单元]，而多个线程共享内存，从而极大地提高了程序的运行效率。
- 4) 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够[独立执行]，必须依存在应用程序中，由应用程序提供多个线程执行控制。
- 5) 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现[进程的调度和管理以及资源分配]。这就是进程和线程的重要区别。

#### 11. Java 中==和 equals 的区别， equals 和 hashCode 的区别（乐视）（Jason）
- "= ="操作符用来比较两个基本类型变量时，比较的是值；用来比较引用类型变量时，[比较的是引用的地址]
- equals方法是基类Object的方法，用于比较两个对象的[内容]是否相同，Object类中equals方法的默认实现使用的==操作符比较，实际开发过程中，我们会重写equals方法，重新定义比较规则

当涉及到像HashMap等与哈希表结构相关的一些类时，会使用到hashCode方法,默认的hashCode实现一般是内存地址对应的数字，所以不同的对象，hashCode（）的返回值是不一样的,equals(object)相同时，hashCode（）的返回值也要尽量相同，当equals(object)不相同时，hashCode（）的返回没有特别的要求，但是也是尽量不相同以获取好的性能



#### 12. ArrayList 和 HashMap的实现原理（美团，百度）（Danny）

#### 13. java 中 int char long 各占多少字节数（Jason
char 2个字节，int 4个字节，long 8个字节

#### 14. java int 与 integer 的区别（Jason）
int 是基本数据类型，integer是包装数据类型（引用类型），JDK1.5之后，自动装包/拆包大大方便了基本类型数据和它们包装类地使用。

#### 15. string、stringbuffer、stringbuilder区别（小米、乐视、百度）（Jason）
共同点：

- String、StringBuffer、StringBuilder都是字符串相关函数
- StringBuffer StringBuilder都是AbstractStringBuilder的子类

不同点：
- String内容不可变，StringBuffer StringBuilder内容可变
- String与StringBuffer线程安全，StringBuilder非线程安全
- 如果程序不是多线程的，那么使用StringBuilder效率高于StringBuffer


#### 16. Java 多态（乐视）（Jason）
静态多态：方法重载

动态多态：方法重写

多态发生的条件：
- 1）要有继承
- 2）要有重写
- 3）父类引用指向子类对象

多态的好处：
- 1）可替换性
- 2）可扩充性
- 3）接口性
- 4）简化性


#### 17. 什么导致线程阻塞（58、美团）（Jason）

阻塞状态的线程的特点是：

该线程放弃CPU的使用，暂停运行，只有等到导致阻塞的原因消除之后才恢复运行。或者是被其他的线程中断，该线程也会退出阻塞状态，同时抛出InterruptedException
- 1）线程执行了Thread.sleep(int millsecond);方法，当前线程放弃CPU，睡眠一段时间，然后再恢复执行
- 2）线程执行一段同步代码，但是尚且无法获得相关的同步锁，只能进入阻塞状态，等到获取了同步锁，才能回复执行。
- 3）线程执行了一个对象的wait()方法，直接进入阻塞状态，等待其他线程执行notify()或者notifyAll()方法。
- 4）线程执行某些IO操作，因为等待相关的资源而进入了阻塞状态。比如说监听system.in，但是尚且没有收到键盘的输入，则进入阻塞状态。




#### 18. 抽象类接口区别（360）（Jason）
- 1）抽象类要被子类继承，接口要被类实现
- 2）接口只能做方法申明，抽象类中可以做方法申明，也可以做方法实现
- 3）接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。
- 4）抽象类里的抽象方法必须全部被子类所实现，如果子类不能全部实现父类抽象方法，那么该子类只能是抽象类。同样，一个实现接口的时候，如不能全部实现接口方法，那么该类也只能为抽象类。
- 5）抽象方法只能申明，不能实现，接口是设计的结果 ，抽象类是重构的结果
- 6）接口可继承接口，并可多继承接口，但类只能单根继承。



#### 19. 容器类之间的区别（乐视、美团）（Jason）
###### 1.Vector和ArrayList  
- vector是线程同步的，所以它也是线程安全的，而arraylist是线程异步的，是不安全的。如果不考虑到线程的安全因素，一般用arraylist效率比较高。
- 如果集合中的元素的数目大于目前集合数组的长度时，vector增长率为目前数组长度的100%,而arraylist增长率为目前数组长度的50%.如过在集合中使用数据量比较大的数据，用vector有一定的优势。
- ArrayList 和Vector是采用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，都允许直接序号索引元素，但是插入数据要设计到数组元素移动等内存操作，所以索引数据快插入数据慢，Vector由于使synchronized方法（线程安全）所以性能上比ArrayList要差

###### 1.arraylist和linkedlist

- 1.ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。
- 2.对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。
- 3.对于新增和删除操作add和remove，LinkedList比较占优势，因为ArrayList要移动数据。这一点要看实际情况的。若只对单条数据插入或删除，ArrayList的速度反而优于LinkedList。但若是批量随机的插入删除数据，LinkedList的速度大大优于ArrayList.因为ArrayList每插入一条数据，要移动插入点及之后的所有数据。

###### 3.HashMap与TreeMap 
- 1、HashMap通过hashcode对其内容进行快速查找，而TreeMap中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果你就应该使用TreeMap（HashMap中元素的排列顺序是不固定的）。集合框架”提供两种常规的Map实现：HashMap和TreeMap (TreeMap实现SortedMap接口)。
- 2、在Map 中插入、删除和定位元素，HashMap 是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。使用HashMap要求添加的键类明确定义了hashCode()和 equals()的实现。　　

###### 4.hashtable与hashmap
- 1.历史原因:Hashtable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现
- 2.同步性:Hashtable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的
- 3.值：只有HashMap可以让你将空值作为一个表的条目的key或value

###### 5.Set与List
- Set中的数据对象没有顺序且不可以重复。
- List中的数据对象有顺序且可以重复。



#### 20. Java 中 HashMap 和 HashTable 的区别（乐视、小米）（Danny）


#### 21. ArrayMap VS HashMap（Danny）

